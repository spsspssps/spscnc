<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: KiCad_BOM_Wizard.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: KiCad_BOM_Wizard.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>#!/usr/bin/env node

/**
*   @license
*   This is the source code file KiCad_BOM_Wizard.js, this is a free KiCad BOM plugin.
*   Copyright (C) 2016  Ronald A. N. Sousa www.hashdefineelectronics.com/
*
*   This program is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with this program.  If not, see {@link http://www.gnu.org/licenses/}.
*
*   @file KiCad_BOM_Wizard.js
*
*   @author Ronald Sousa http://hashdefineelectronics.com/kicad-bom-wizard/
*
*   @version 0.0.2
*
*   @fileoverview This KiCad plugin can be used to create custom BOM files based on easy
*   configurable templates files. The plugin is writing in JavaScript and has been
*   designed to integrate into KiCadâ€™s BOM plugin manager.
*
*   {@link http://hashdefineelectronics.com/kicad-bom-wizard/|Project Page}
*
*   {@link https://github.com/HashDefineElectronics/KiCad_BOM_Wizard.git|Repository Page}
*
*   @requires xml2js
*
*/

/**
*   Defines the plugin revision number
*/
var PluginRevisionNumber = '0.0.2'

/**
*   Defines KiCad Revision number
*/
var KiCadXMLRevision = 'D'

/**
*   Defines the minimum number of arguments this plugins takes
*/
var MinmumNumOfExpectedArguments = 4

/**
*   holds the processed header data
*/
var OutputHeader = ''

/**
*   holds the template data for main body template should be KiCadXmlFilePath/template.conf
*/
var Template = null

/**
*   holds the template data for table group should be KiCadXmlFilePath/group.conf
*/
var GroupTemplate = null

/**
*   holds the template data for table rows should be KiCadXmlFilePath/row.conf
*/
var RowTemplate = null

/**
*   holds the template data for table headers
*   should be KiCadXmlFilePath/headers.conf
*/
var HeadersTemplate = null

/**
*   holds the template data for fields
*   should be KiCadXmlFilePath/fields.conf
*/
var FieldsTemplate = null

/**
*   This is the project KiCad XML file to use to
*   extract the BOM information
*/
var KiCadXmlFilePath = ''

/**
*   the path and file name to use to create the output BOM
*/
var OutputFilePath = ''

/**
*   Path is used to handle parsing system path urls
*/
var Path = require('path')

/**
*   This is the path to the template files to use
*   when creating the BOM
*/
var TemplateFolder = Path.join(__dirname, '/Template/')

/**
*   javascript object class of the KiCadXmlFilePath file
*/
var UserProjectNetData = null

/**
*   keep track of the number of unique parts found while
*   creating the BOM
*/
var NumberOfUniqueParts = 0

/**
*   keep track of the number of parts found while
*   creating the BOM
*/
var TotalNumberOfParts = 0

// Get cli user arguments
GetArguments()

// print system information
PluginDetails()

// Run the first task.
Task('STATE_GET_XML_DATA')

/**
*   This will check the entire part list for a matching
*   value and fields and return the part's index number that matches
*
*   @param source holds the original list of unsorted parts
*   @param searchTerm the part information to search for
*   @param listOfGroups holds the list of groups
*
*   @returns -1 = no match else the index number of the found item
*/
function SearchUniquePartIndex (source, searchTerm, listOfGroups) {
  var FieldsTestResult = true

  for (var Index = 0; Index &lt; source.length; Index++) {
    // part value matches
    if (searchTerm.Value[0] === source[Index].Value[0]) {
      for (var FieldIndex = 0; FieldIndex &lt; listOfGroups.length; FieldIndex++) {
        // If either one is true
        if (listOfGroups[ FieldIndex ] in searchTerm.Fields || listOfGroups[ FieldIndex ] in source[Index].Fields) {
          // If either one is true then both have to be set
          if (listOfGroups[ FieldIndex ] in searchTerm.Fields &amp;&amp;
                listOfGroups[ FieldIndex ] in source[Index].Fields &amp;&amp;
                searchTerm.Fields[ listOfGroups[ FieldIndex ] ] === source[Index].Fields[ listOfGroups[ FieldIndex ] ]) {
            // Do nothing
          } else {
            FieldsTestResult = false
          }
        }
      }

      // We have a match
      if (FieldsTestResult) {
        return Index
      }
    }
  }

  return -1
}

/**
*   creates the table
*
*   @param fieldsList the array that has all the various filed names
*   @param GroupedList the array that has all the parts grouped by the ref prefix
*   @param partGroupedList the array that actually contains all the parts data
*
*   @returns the output
*/
function GenerateTable (fieldsList, groupedList, partGroupedList) {
  var ReturnOutput = ''
  var FieldIndex = 0

  OutputHeader = HeadersTemplate.replace(/&lt;!--HEADER_ROW-->/g, 'Ref')
  OutputHeader = OutputHeader.replace(/&lt;!--HEADER_CLASS_REF_TAG-->/g, 'HeadRefTag')
  OutputHeader = OutputHeader.replace(/&lt;!--HEADER_CLASS_QTY_TAG-->/g, '')
  OutputHeader = OutputHeader.replace(/&lt;!--HEADER_CLASS_VALUE_TAG-->/g, '')

  OutputHeader += HeadersTemplate.replace(/&lt;!--HEADER_ROW-->/g, 'Qty')
  OutputHeader = OutputHeader.replace(/&lt;!--HEADER_CLASS_REF_TAG-->/g, '')
  OutputHeader = OutputHeader.replace(/&lt;!--HEADER_CLASS_QTY_TAG-->/g, 'HeadQtyTag')
  OutputHeader = OutputHeader.replace(/&lt;!--HEADER_CLASS_VALUE_TAG-->/g, '')

  OutputHeader += HeadersTemplate.replace(/&lt;!--HEADER_ROW-->/g, 'Value')
  OutputHeader = OutputHeader.replace(/&lt;!--HEADER_CLASS_REF_TAG-->/g, '')
  OutputHeader = OutputHeader.replace(/&lt;!--HEADER_CLASS_QTY_TAG-->/g, '')
  OutputHeader = OutputHeader.replace(/&lt;!--HEADER_CLASS_VALUE_TAG-->/g, 'HeadValueTag')

  fieldsList.sort()

  for (FieldIndex = 0; FieldIndex &lt; fieldsList.length; FieldIndex++) {
    OutputHeader += HeadersTemplate.replace(/&lt;!--HEADER_ROW-->/g, fieldsList[ FieldIndex ])
    OutputHeader = OutputHeader.replace(/&lt;!--HEADER_CLASS_REF_TAG-->/g, '')
    OutputHeader = OutputHeader.replace(/&lt;!--HEADER_CLASS_QTY_TAG-->/g, '')
    OutputHeader = OutputHeader.replace(/&lt;!--HEADER_CLASS_VALUE_TAG-->/g, '')
  }

  groupedList.sort()

  // keep track if the table row is odd or even. true = even else is odd
  var RowIsEvenFlag = false

  for (var Group in groupedList) {
    // take a copy of the table template
    var TableTemp = GroupTemplate
    var GroupdName = groupedList[Group]

    TableTemp = TableTemp.replace(/&lt;!--GROUP_CLASS_TAG-->/g, 'group_' + GroupdName)
    TableTemp = TableTemp.replace(/&lt;!--GROUP_TITLE_TEXT-->/g, GroupdName)

    var TableRowAll = ''
    for (var Item in partGroupedList[GroupdName]) {
      var TempRow = RowTemplate
      var RefTemp = ''

      for (var Ref in partGroupedList[GroupdName][Item].Ref) {
        RefTemp += Ref + ' '
      }

      if (RowIsEvenFlag) {
        TempRow = TempRow.replace(/&lt;!--ROW_CLASS_ODD_EVEN_TAG-->/g, 'RowEvenTag')
      } else {
        TempRow = TempRow.replace(/&lt;!--ROW_CLASS_ODD_EVEN_TAG-->/g, 'RowOddTag')
      }
      TempRow = TempRow.replace(/&lt;!--ROW_PART_REF-->/g, RefTemp)
      TempRow = TempRow.replace(/&lt;!--ROW_PART_QTY-->/g, partGroupedList[GroupdName][Item].Count)
      TempRow = TempRow.replace(/&lt;!--ROW_PART_VALUE-->/g, partGroupedList[GroupdName][Item].Value)

      TempRow = TempRow.replace(/&lt;!--HEADER_CLASS_REF_TAG-->/g, 'HeadRefTag')
      TempRow = TempRow.replace(/&lt;!--HEADER_CLASS_QTY_TAG-->/g, 'HeadQtyTag')
      TempRow = TempRow.replace(/&lt;!--HEADER_CLASS_VALUE_TAG-->/g, 'HeadValueTag')

      var FieldsTemp = ''

      for (FieldIndex = 0; FieldIndex &lt; fieldsList.length; FieldIndex++) {
        var SingleFieldTemp = FieldsTemplate

        SingleFieldTemp = SingleFieldTemp.replace(/&lt;!--FIELD_CLASS_TAG-->/g, 'Field_' + fieldsList[ FieldIndex ])

        if (partGroupedList[ GroupdName ][ Item ].Fields[ fieldsList[ FieldIndex ] ]) {
          SingleFieldTemp = SingleFieldTemp.replace(/&lt;!--FIELD-->/g, partGroupedList[ GroupdName ][ Item ].Fields[ fieldsList[ FieldIndex ] ].replace(/,/g, ' '))
        } else {
          SingleFieldTemp = SingleFieldTemp.replace(/&lt;!--FIELD-->/g, ' ')
        }

        FieldsTemp += SingleFieldTemp
      }

      TableRowAll += TempRow.replace(/&lt;!--ROW_PART_FIELDS-->/g, FieldsTemp)

      RowIsEvenFlag = !RowIsEvenFlag
    }

    TableTemp = TableTemp.replace(/&lt;!--GROUP_ROW_DATA-->/g, TableRowAll)

    ReturnOutput += TableTemp
  }
  return ReturnOutput
}

/**
*   return the generated part table
*
*   @returns the output
*/
function ExtractAndGenerateDataForThePart () {
  var PartGroupedList = []
  // holds the list of groups. This is used to make sorting easier
  var GroupedList = []
  var UniquePartList = []
  var ListOfFields = []
  NumberOfUniqueParts = 0
  TotalNumberOfParts = 0
  var PartIndex = 0

  // Get the list of groups we are going to use
  UserProjectNetData.export.components[0].comp.forEach(function (Part) {
    if (Part.fields) {
      Part.fields.forEach(function (value) {
        value.field.forEach(function (value) {
          if (ListOfFields.indexOf(value.$.name) === -1) {
            // if the returned index is -1 then we know  that we know we don't have this item
            ListOfFields.push(value.$.name)
          }
        })
      })
    }
  })

  // get the list of fields and grouped the component with the same value
  UserProjectNetData.export.components[0].comp.forEach(function (Part) {
    var TempFieldHolder = []

    if (Part.fields) {
      Part.fields.forEach(function (value) {
        value.field.forEach(function (value) {
          TempFieldHolder[value.$.name] = value['_']
        })
      })
    }

    var TempPart = {'Value': Part.value, 'Count': 1, 'Ref': [], 'Fields': TempFieldHolder, 'RefPrefix': Part.$.ref.replace(/[0-9]/g, '')}

    PartIndex = SearchUniquePartIndex(UniquePartList, TempPart, ListOfFields)

    // Do we have this part?
    if (PartIndex === -1) {
      UniquePartList.push(TempPart)
      PartIndex = UniquePartList.length
      PartIndex--

      UniquePartList[PartIndex].Ref[Part.$.ref] = Part.$.ref

      if (Part.fields) {
        Part.fields.forEach(function (value) {
          value.field.forEach(function (value) {
            if (ListOfFields.indexOf(value.$.name) === -1) {
              // if the returned index is -1 then we know  that we know we don't have this item
              ListOfFields.push(value.$.name)
            }
          })
        })
      }

      if (typeof PartGroupedList[UniquePartList[PartIndex].RefPrefix] === 'undefined') {
        GroupedList.push(UniquePartList[PartIndex].RefPrefix)
        PartGroupedList[UniquePartList[PartIndex].RefPrefix] = []
        PartGroupedList[UniquePartList[PartIndex].RefPrefix].push(UniquePartList[PartIndex])
      } else {
        PartGroupedList[UniquePartList[PartIndex].RefPrefix].push(UniquePartList[PartIndex])
      }

      NumberOfUniqueParts++
    } else {
      UniquePartList[PartIndex].Count++
      UniquePartList[PartIndex].Ref[Part.$.ref] = Part.$.ref
    }

    TotalNumberOfParts++
  })

  return GenerateTable(ListOfFields, GroupedList, PartGroupedList)
}

/**
*   This will generate the Bill of material based on the
*   template given
*/
function GenerateBOM () {
  if (UserProjectNetData != null &amp;&amp; Template != null) {
    Message('Generating BOM [ ' + OutputFilePath + ' ]')

    var Result = ExtractAndGenerateDataForThePart()

    Template = Template.replace(/&lt;!--DATE_GENERATED-->/g, UserProjectNetData.export.design[0].date)
    Template = Template.replace(/&lt;!--TITLE-->/g, UserProjectNetData.export.design[0].sheet[0].title_block[0].title)
    Template = Template.replace(/&lt;!--DATE-->/g, UserProjectNetData.export.design[0].sheet[0].title_block[0].date)
    Template = Template.replace(/&lt;!--COMPANY-->/g, UserProjectNetData.export.design[0].sheet[0].title_block[0].company)
    Template = Template.replace(/&lt;!--REVISON-->/g, UserProjectNetData.export.design[0].sheet[0].title_block[0].rev)
    Template = Template.replace(/&lt;!--COMMENT_1-->/g, UserProjectNetData.export.design[0].sheet[0].title_block[0].comment[0].$.value)
    Template = Template.replace(/&lt;!--COMMENT_2-->/g, UserProjectNetData.export.design[0].sheet[0].title_block[0].comment[1].$.value)
    Template = Template.replace(/&lt;!--COMMENT_3-->/g, UserProjectNetData.export.design[0].sheet[0].title_block[0].comment[2].$.value)
    Template = Template.replace(/&lt;!--COMMENT_4-->/g, UserProjectNetData.export.design[0].sheet[0].title_block[0].comment[3].$.value)
    Template = Template.replace(/&lt;!--TOTAL_NUM_OF_PARTS-->/g, TotalNumberOfParts)
    Template = Template.replace(/&lt;!--TOTAL_NUM_OF_UNIQUE_PARTS-->/g, NumberOfUniqueParts)
    Template = Template.replace(/&lt;!--CLASS_HEADER_TAG-->/g, OutputHeader)
    Template = Template.replace(/&lt;!--BOM_TABLE-->/g, Result)
    // output BOM
    var OutputFilePathWrite = require('fs')

    OutputFilePathWrite.writeFile(OutputFilePath, Template, function (returnError) {
      if (returnError) {
        ErrorMessage(returnError)
      }

      Message('BOM created')
    })
  } else {
    ErrorMessage('Error generating BOM')
  }
}

/**
*   read the user KiCad file. This will also convert the
*   the xml data to javascript object.
*/
function ReadXmlFile () {
  var xml2js = require('xml2js')
  var parser = new xml2js.Parser()

  var XMLFile = require('fs')

  Message('reading KiCad XML file [ ' + KiCadXmlFilePath + ' ]')

  XMLFile.readFile(KiCadXmlFilePath, function (returnError, output) {
    // returnError should return null if the file was read correctly
    if (returnError === null) {
      // Convert kicad XML data to javascript object class
      parser.parseString(output, function (returnError, result) {
        // returnError should return null if the data was converted correctly
        if (returnError === null) {
          UserProjectNetData = result

          if (UserProjectNetData.export.$.version !== KiCadXMLRevision) {
            ErrorMessage('Incompatible KiCad XML version: Expected ' + KiCadXMLRevision + ' Found ' + UserProjectNetData.export.$.version)
          }

          Task('STATE_READ_TEMPLATE')
        } else {
          ErrorMessage(returnError)
        }
      })
    } else {
      ErrorMessage(returnError)
    }
  })
}

/**
*   read template.conf
*/
function ReadTemplateFile () {
  Message('Reading Template [ ' + TemplateFolder + ' ]')

  var FileTemp = require('fs')

  FileTemp.readFile(TemplateFolder + '/template.conf', 'utf8', function (returnError, output) {
    // returnError should return null if the data was read correctly
    if (returnError === null) {
      Template = output
      Task('STATE_READ_TABLE_TEMPLATE')
    } else {
      ErrorMessage('Error reading template.conf')
    }
  })
}

/**
*   read group.conf
*/
function ReadGroupFile () {
  var FileTemp = require('fs')

  FileTemp.readFile(TemplateFolder + '/group.conf', 'utf8', function (returnError, output) {
    // returnError should return null if the data was read correctly
    if (returnError === null) {
      GroupTemplate = output
      Task('STATE_READ_TABLE_ROW_HEADER_TEMPLATE')
    } else {
      ErrorMessage('Error reading group.conf')
    }
  })
}

/**
*   read headers.conf
*/
function ReadHeadersFile () {
  var FileTemp = require('fs')

  FileTemp.readFile(TemplateFolder + '/headers.conf', 'utf8', function (returnError, output) {
    // returnError should return null if the data was read correctly
    if (returnError === null) {
      HeadersTemplate = output
      Task('STATE_READ_TABLE_ROW_TEMPLATE')
    } else {
      ErrorMessage('Error reading headers.conf')
    }
  })
}

/**
*   read row.conf
*/
function ReadRowFile () {
  var FileTemp = require('fs')

  FileTemp.readFile(TemplateFolder + '/row.conf', 'utf8', function (returnError, output) {
    // returnError should return null if the data was read correctly
    if (returnError === null) {
      RowTemplate = output
      Task('STATE_READ_Field_TEMPLATE')
    } else {
      ErrorMessage('Error reading row.conf')
    }
  })
}

/**
*   read fields.conf
*/
function ReadFieldFile () {
  var FileTemp = require('fs')

  FileTemp.readFile(TemplateFolder + '/fields.conf', 'utf8', function (returnError, output) {
    // returnError should return null if the data was read correctly
    if (returnError === null) {
      FieldsTemplate = output
      Task('STATE_GENERATE_BOM')
    } else {
      ErrorMessage('Error reading fields.conf')
    }
  })
}

/**
*   Handles getting the arguments pass to the plugin
*/
function GetArguments () {
  // make sure that we have enough parameter to continue
  if (process.argv.length &lt; MinmumNumOfExpectedArguments) {
    ErrorMessage('Too few arguments. Found ' + process.argv.length + ' Expected at least ' + MinmumNumOfExpectedArguments)
  }

  KiCadXmlFilePath = process.argv[2]
  OutputFilePath = process.argv[3]

  if (process.argv.length > MinmumNumOfExpectedArguments) {
    // the user has specified template they wish to use.

    if (PathExist(process.argv[4])) {
      // check if use template path exist

      TemplateFolder = process.argv[4]
    } else if (PathExist(TemplateFolder + process.argv[4])) {
      // now check if the user is wanting to use a  template in KiCad_BOM_Wizard/Template

      TemplateFolder += process.argv[4]
    } else {
      ErrorMessage('Template directory not found: [ ' + process.argv[4] + ' ]')
    }
  } else {
    TemplateFolder += 'HTML'
  }
}

/**
*   This function can be used to check if the given path
*   exist
*
*   @returns true on success else false false
*/
function PathExist (path) {
  // first check if directory exist
  var FileSystem = require('fs')
  try {
    if (FileSystem.statSync(path).isDirectory()) {
      return true
    }
  } catch (ex) {
    // we can ignore the error message
  }

  return false
}

/**
*   Handles the machine state.
*/
function Task (state) {
  switch (state) {
    case 'STATE_GET_XML_DATA':
      ReadXmlFile()
      break

    case 'STATE_READ_TEMPLATE':
      ReadTemplateFile()
      break

    case 'STATE_READ_TABLE_TEMPLATE':
      ReadGroupFile()
      break

    case 'STATE_READ_TABLE_ROW_HEADER_TEMPLATE':
      ReadHeadersFile()
      break

    case 'STATE_READ_TABLE_ROW_TEMPLATE':
      ReadRowFile()
      break

    case 'STATE_READ_Field_TEMPLATE':
      ReadFieldFile()
      break

    case 'STATE_GENERATE_BOM':
      GenerateBOM()
      break

    default:
      ErrorMessage('Task() default error')
      break
  }
}

/*
*   This function will display the plugin information
*   and the data pass by user.
*/
function PluginDetails () {
  console.log('KiCad_BOM_Wizard Rev: ' + PluginRevisionNumber)
}

/**
*   this function is used to make a standard format
*   for error messages.
*   this also handle exiting the program
*/
function ErrorMessage (message) {
  console.log('\n\n')
  console.log('Error *****')
  console.log(message)
  console.log('\n\n')
  process.exit(1)
}

/*
*   this function is used to make a standard format
*   for error messages.
*   this also handle exiting the program
*/
function Message (message) {
  console.log(message)
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#ErrorMessage">ErrorMessage</a></li><li><a href="global.html#ExtractAndGenerateDataForThePart">ExtractAndGenerateDataForThePart</a></li><li><a href="global.html#FieldsTemplate">FieldsTemplate</a></li><li><a href="global.html#GenerateBOM">GenerateBOM</a></li><li><a href="global.html#GenerateTable">GenerateTable</a></li><li><a href="global.html#GetArguments">GetArguments</a></li><li><a href="global.html#GroupTemplate">GroupTemplate</a></li><li><a href="global.html#HeadersTemplate">HeadersTemplate</a></li><li><a href="global.html#KiCadXmlFilePath">KiCadXmlFilePath</a></li><li><a href="global.html#KiCadXMLRevision">KiCadXMLRevision</a></li><li><a href="global.html#MinmumNumOfExpectedArguments">MinmumNumOfExpectedArguments</a></li><li><a href="global.html#NumberOfUniqueParts">NumberOfUniqueParts</a></li><li><a href="global.html#OutputFilePath">OutputFilePath</a></li><li><a href="global.html#OutputHeader">OutputHeader</a></li><li><a href="global.html#Path">Path</a></li><li><a href="global.html#PathExist">PathExist</a></li><li><a href="global.html#PluginRevisionNumber">PluginRevisionNumber</a></li><li><a href="global.html#ReadFieldFile">ReadFieldFile</a></li><li><a href="global.html#ReadGroupFile">ReadGroupFile</a></li><li><a href="global.html#ReadHeadersFile">ReadHeadersFile</a></li><li><a href="global.html#ReadRowFile">ReadRowFile</a></li><li><a href="global.html#ReadTemplateFile">ReadTemplateFile</a></li><li><a href="global.html#ReadXmlFile">ReadXmlFile</a></li><li><a href="global.html#RowTemplate">RowTemplate</a></li><li><a href="global.html#SearchUniquePartIndex">SearchUniquePartIndex</a></li><li><a href="global.html#Task">Task</a></li><li><a href="global.html#Template">Template</a></li><li><a href="global.html#TemplateFolder">TemplateFolder</a></li><li><a href="global.html#TotalNumberOfParts">TotalNumberOfParts</a></li><li><a href="global.html#UserProjectNetData">UserProjectNetData</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sun Feb 07 2016 11:32:03 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
